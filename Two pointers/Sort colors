def sort_colors(colors):
    # Initialize the start, current, and end pointers
    start, current, end = 0, 0, len(colors) - 1

    # Iterate through the list until the current pointer exceeds the end pointer
    while current <= end:
        if colors[current] == 0:
            # If the current element is 0 (red), swap it with the element at the start pointer
            # This ensures the red element is placed at the beginning of the array
            colors[start], colors[current] = colors[current], colors[start]
            # Move both the start and current pointers one position forward
            current += 1
            start += 1

        elif colors[current] == 1:
            # If the current element is 1 (white), just move the current pointer one position forward
            current += 1

        else:
            # If the current element is 2 (blue), swap it with the element at the end pointer
            # This pushes the blue element to the end of the array
            colors[current], colors[end] = colors[end], colors[current]
            # Move the end pointer one position backward
            end -= 1
    return colors


# Driver code
def main():
    inputs = [[0, 1, 0], [1, 1, 0, 2], [2, 1, 1, 0, 0], [2, 2, 2, 0, 1, 0], [2, 1, 1, 0, 1, 0, 2]]

    for i in range(len(inputs)):
        colors=inputs[i]
        print(i + 1, ".\tcolors:", colors)
        sort_colors(colors)
        print("\n\tThe sorted array is:", colors)
        print("-" * 100)

if __name__ == "__main__":
    main()
Solution summary#
To summarize, solving this problem involves the following steps:

Traverse the array and swap elements, as required, to organize them correctly.

If the encountered color is red, swap its value with that of the start pointer. If the color is blue, swap its value with that of the end pointer.

White elements are skipped, and pointers are adjusted accordingly.

The array is sorted when the end pointer moves to the left of the current pointer.

